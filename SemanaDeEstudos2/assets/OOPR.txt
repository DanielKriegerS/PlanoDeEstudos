	***	PILARES DE POO (OOP):
GLOSÁRIO:
	POO = PROGRAMAÇÃO - ORIENTADA A OBJETOS.
	OOP = OBJECT-ORIENTED PROGRAMMING.
	SRP = Single-Responsability Principle.

1: ABSTRAÇÃO;
2: ENCAPSULAMENTO;
3: HERANÇA;
4: POLIMORFISMO;

Abstração:
	A abstração (no contexto de OOP) é a ideia de "analisar algo e separar/destacar".
	No caso, utilizamos esse método mental para "separar/destacar" a parte do objeto analisado necessária em um sistema.
	
	Um exemplo do conceito de Abstração na OOP seria a criação da classe a partir de algo real.
	
	EX.: Você pode ter uma API de Produtos (que será simplificada nesse momento, para fins de continuidade). O objetivo dessa API é calcular o preço médio e o maior/menor valor desses produtos. Esses produtos não podem ter um valor negativo, nem ter nome em branco.
	
		Ao pensar nessa situação, por ser simples, é fácil inferir que a classe principal a ser abstraída é Produto. 
		Em um contexto real, uma API pode precisar ter diferentes classes interagindo para que um sistema complexo funcione.
		
		Nesse ponto, temos a definição da classe:
		class Product {}
		
		Estamos falando em calculos de preço, já podemos então adicionar esse atributo:
		class Product {
			double productValue; // double é uma boa representação de preço? Vale a pena a pesquisa! ;)
		}
		
		Como um usuário poderia distinguir entre diferentes produtos?
		Programacionalmente, podemos pensar em um identificador, mas para um "usuário comum" um ID não é muito descritivo. Poderíamos dar um nome ao produto:
		class Product {
			String name;
			double productValue; // vamos usar double apenas para o exemplo
		}
		
		(Opcional) Se pensarmos à frente, poderíamos já adicionar o identificador programático (ID):
		class Product {
			int Id; //usaremos int para o exemplo, porém "na vida real", raramente é usado um tipo primitivo
			String name;
			double productValue;
		}
		
		Nesse ponto, temos como descrever ao usuário qual produto tem qual valor e também como executar calculos com os diferentes valores de produtos. Faria sentido sabermos qual a cor de cada produto? Ou se é um eletrodoméstico?
		Dessa forma, se você entende que sim, pode adicionar os atributos referentes a essas características. Ou outras que ache conveniente, mas pense: em que momento irei utilizar essa informação?
		
		Podemos a partir daqui, pensar em o que essa classe faz. Se pensar pelo lado "real", produtos podem ter diversas utilidades, cada um tem a sua. Você acha que faz sentido termos a utilidade do produto como um atributo ou método?
		
		Considerando que queremos calcular informações de preço e garantir que o usuário final receba corretamente os dados processados, a regra relacionada à "validação de dados do produto" deve ser da responsabilidade do produto. Isso segue o princípio SRP (Pesquise!). 
		Note que o cálculo de preços foge da responsabilidade de uma unica entidade (um único produto), logo é uma regra de um contexto "acima" e não ficaria dentro do produto. Reflita sobre isso, pode haver controvérsias.
		
		Com essa abstração de "fazer" da classe, teríamos:
		class Product {
			public int Id; 
			public String name;
			public double productValue;
			
			// esse é o método inicial para validar o produto 
			// devolve um true or false (valido ou não)
			boolean validateProduct() {
				productName = name;
				productValue = productValue;
				
				if (productName.isEmpty()) { // isEmpty é uma função de String, logo do productName. 
											 //Verifica se está vazio.
					return false;
				}
				
				if (p.productValue < 0) {
					return false; // já viu produto com preço negativo? Se não quiser um preço com valor = 0, ajuste.
				}
				
				return true; // se tem um nome e preço >= 0, é válido.
				
				// há uma forma simplificada de escrever isso...
			}
			
			/*  Aqui vale a pena parar e pensar... Esse validador de produto tem qual função?
				Ele valida um produto!.. Nesse caso, porque ele está validando o nome do produto e o valor do produto?
				Se você perceber, na verdade "validar produto" é algo genérico.
				Validar o produto significa (nesse contexto):
				1 - o produto ter um nome.
				2 - o produto ter um valor positivo.
				Mas e se o contexto de validação mudar? 
				Se por acaso você quiser alterar o nome do produto? Vale a pena validar o valor também?
				Ou vice-versa.
				Talvez validar o produto seja um conjunto de funções..
			*/
		}
		
		Com isso a classe produto está abstraída! :D
		Mas isso é minha opinião, pode adicionar mais complexidade ao exemplo. Apenas lembre de aplicar os próximos passos a cada nova funcionalidade. Nosso exemplo apenas contempla as funcionalidades descritas no topo.
		
Encapsulamento:
	Um entendimento prévio necessário para o conceito de Encapsulamento é o conceito de packages (pacotes) e a visibilidade entre eles: public, protected, private e default.
	Resumindo - public 		> vísivel de qualquer lugar, dentro ou fora do pacote.
				protected 	> acessível dentro do mesmo pacote ou por subclasses (mesmo fora do pacote).
				private 	> acessível apenas dentro da classe.
				default 	> apenas dentro do mesmo pacote (é só deixar sem palavra-chave).
	Sendo objetivo em geral, para APIs, utilizamos apenas public e private, embora seja importante entender os conceitos das outras duas formas de visibildade.
	
	Também é necessário entender o conceito de instanciação, que resumidamente significa gerar um objeto a partir de determinada classe. Vale a pesquisa, mas pense em uma classe como a "forma de bolo", enquanto que o Objeto é o bolo feito...
	Em nosso contexto, podemos verificar que a classe Product tem um nome e um valor (e opcionalmente um ID).
	A linha (com os devidos imports -> vale a pena entender imports):
		Product p = new Product();
	Está gerando um novo Product chamado "p".
	Nessa API, quando falamos em Product, estamos falando em algo abstrato, que pode ser feito, mas ainda não existe. Ao falar em "p" que é um new Product(), estamos falando em um objeto p, que tem como características as definições de Product. Aqui vale a pena entender um pouco a respeito das inicializações de variáveis, mas se verificassemos p.name e p.productValue, teríamos: "", 0.0. Tente usar system.out.println() para confirmar.
	 
	Se você (na classe Main) fizer algo como:
		p.name = "";
	
	Isso se tornará o novo name de "p". Mas dentro de "p" não temos o método validateProduct(Product p)?
	 
	Entendendo os conceitos necessários, seguimos..
	
	Temos a classe Product, com seus atributos e ações (métodos). Digamos que temos também, a classe Main:
	public class Main() {
		public static void main(String[] args){} // vale muito a pena entender porque esse main faz o java "rodar"
	}
	
	se você fizer:
	public class Main() {
		public static void main(String[] args){
			Product p = new Product();
			p.id = -11231;
			p.name = "";
			p.productValue = -10.0;
		}
	}
	
	Isso irá funcionar. Porém, é realmente assim que sua classe deveria se comportar?
	Se você possui validadores e também quer manter seguras as informações do objeto gerado a partir da sua classe, o ideal seria não deixar seus dados disponíveis publicamente. Na verdade, na grande maioria dos casos reais, os atributos (que carregarão os dados) da sua classe serão sempre privados. Dessa forma, você garante que apenas a própria classe tenha acesso a eles e que apenas ela possa alterá-los, de acordo com as regras que ela própria define.
	
	Teríamos Product da seguinte forma, então:
	public class Product {
    private String name;
    private double productValue;
	
	// métodos validadores.
	}

Herança:

Classe base -> Detém comportamentos e atributos pertinentes;

Classe derivada -> 